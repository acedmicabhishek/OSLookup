# Chapter 4: Threads

## Overview

A thread is a basic unit of CPU utilization; it comprises a thread ID, a program counter, a register set, and a stack. It shares with other threads belonging to the same process its code section, data section, and other operating-system resources, such as open files and signals. A traditional (or heavyweight) process has a single thread of control. If a process has multiple threads of control, it can perform more than one task at a time.

**Motivation for Threads:**
-   **Responsiveness:** Multithreading an interactive application may allow a program to continue running even if part of it is blocked or is performing a lengthy operation.
-   **Resource Sharing:** Processes can only share resources through techniques such as shared memory and message passing. Threads, however, share the memory and the resources of the process to which they belong by default.
-   **Economy:** Allocating memory and resources for process creation is costly. Because threads share resources of the process to which they belong, it is more economical to create and context-switch threads.
-   **Scalability:** The benefits of multithreading can be greatly increased in a multiprocessor architecture, where threads may be running in parallel on different processing cores.

## Multicore Programming

A recent trend in computer architecture is to place multiple computing cores on a single chip. Each core appears to the operating system as a separate CPU. Multithreaded programming provides a mechanism for more efficient use of these multiple cores and for improved concurrency.

**Challenges in Multicore Programming:**
-   **Dividing activities:** Examining applications to find areas that can be divided into separate, concurrent tasks.
-   **Balance:** Ensuring that the tasks perform equal work of equal value.
-   **Data splitting:** The data accessed and manipulated by the tasks must be divided to run on separate cores.
-   **Data dependency:** The data must be synchronized to ensure that the execution of the tasks is not violating any data dependencies.
--   **Testing and debugging:** Testing and debugging concurrent programs is inherently more difficult than testing and debugging single-threaded applications.

## Multithreading Models

Support for threads may be provided either at the user level, for user threads, or by the kernel, for kernel threads.

-   **Many-to-One Model:** Maps many user-level threads to one kernel thread. Thread management is done by the thread library in user space, so it is efficient. However, the entire process will block if a thread makes a blocking system call.
-   **One-to-One Model:** Maps each user thread to a kernel thread. This model provides more concurrency than the many-to-one model. The only drawback to this model is that creating a user thread requires creating the corresponding kernel thread.
-   **Many-to-Many Model:** Multiplexes many user-level threads to a smaller or equal number of kernel threads. This model suffers from neither of the shortcomings of the one-to-one or many-to-one models.

## Thread Libraries

A thread library provides the programmer with an API for creating and managing threads. There are two primary ways of implementing a thread library:
1.  To provide a library entirely in user space with no kernel support.
2.  To implement a kernel-level library supported directly by the operating system.

**Common Thread Libraries:**
-   **Pthreads:** A POSIX standard API for thread creation and synchronization.
-   **Windows Threads:** The thread library for Windows systems.
-   **Java Threads:** The Java language and its API provide a rich set of features for creating and managing threads.

## Implicit Threading

Implicit threading is a technique where the creation and management of threads are transferred from the application developer to the compiler and run-time libraries.

**Methods for Implicit Threading:**
-   **Thread Pools:** Create a number of threads at process startup and place them into a pool, where they sit and wait for work.
-   **OpenMP:** A set of compiler directives and an API for programs written in C, C++, or FORTRAN that provides support for parallel programming in shared-memory environments.
-   **Grand Central Dispatch (GCD):** A technology for Apple's macOS and iOS operating systems, is a runtime library that helps developers by moving the threading decisions to the system.

## Threading Issues

-   **`fork()` and `exec()` System Calls:** If one thread in a program calls `fork()`, does the new process duplicate all threads, or is the new process single-threaded?
-   **Signal Handling:** Signals are used in UNIX systems to notify a process that a particular event has occurred. A signal may be received either synchronously or asynchronously, depending on the source of and the reason for the event being signaled.
-   **Thread Cancellation:** The task of terminating a thread before it has completed.
-   **Thread-Local Storage:** Threads belonging to a process share the data of the process. However, in some circumstances, each thread might need its own copy of certain data. We call such data thread-local storage (TLS).
-   **Scheduler Activations:** A scheme for communication between the user-thread library and the kernel.

## Operating System Examples

-   **Windows Threads:** Windows implements the one-to-one mapping, where each user-level thread maps to an associated kernel thread.
-   **Linux Threads:** Linux refers to them as tasks rather than threads. The `clone()` system call is used to create a new task.