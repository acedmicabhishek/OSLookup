# Chapter 7: Deadlocks

## System Model

In a multiprogramming environment, several processes may compete for a finite number of resources. A process requests resources, and if the resources are not available at that time, the process enters a waiting state. Sometimes, a waiting process is never again able to change state, because the resources it has requested are held by other waiting processes. This situation is called a **deadlock**.

A set of blocked processes each holding a resource and waiting to acquire a resource held by another process in the set.

## Deadlock Characterization

A deadlock situation can arise if the following four conditions hold simultaneously in a system:

1.  **Mutual Exclusion:** At least one resource must be held in a nonsharable mode; that is, only one process at a time can use the resource. If another process requests that resource, the requesting process must be delayed until the resource has been released.
2.  **Hold and Wait:** A process must be holding at least one resource and waiting to acquire additional resources that are currently being held by other processes.
3.  **No Preemption:** Resources cannot be preempted; that is, a resource can be released only voluntarily by the process holding it, after that process has completed its task.
4.  **Circular Wait:** A set {P0, P1, ..., Pn} of waiting processes must exist such that P0 is waiting for a resource that is held by P1, P1 is waiting for a resource that is held by P2, ..., Pnâˆ’1 is waiting for a resource that is held by Pn, and Pn is waiting for a resource that is held by P0.

## Methods for Handling Deadlocks

Generally speaking, we can deal with the deadlock problem in one of three ways:

1.  We can use a protocol to prevent or avoid deadlocks, ensuring that the system will never enter a deadlocked state.
2.  We can allow the system to enter a deadlocked state, detect it, and recover.
3.  We can ignore the problem altogether and pretend that deadlocks never occur in the system. This is the solution used by most operating systems, including UNIX and Windows.

## Deadlock Prevention

For a deadlock to occur, each of the four necessary conditions must hold. By ensuring that at least one of these conditions cannot hold, we can prevent the occurrence of a deadlock.

-   **Mutual Exclusion:** For sharable resources (e.g., read-only files), the mutual-exclusion condition need not hold. However, some resources are inherently nonsharable (e.g., printers).
-   **Hold and Wait:** To ensure that the hold-and-wait condition never occurs, we must guarantee that, whenever a process requests a resource, it does not hold any other resources.
-   **No Preemption:** If a process that is holding some resources requests another resource that cannot be immediately allocated to it, then all resources currently being held are preempted.
-   **Circular Wait:** Impose a total ordering of all resource types, and require that each process requests resources in an increasing order of enumeration.

## Deadlock Avoidance

Deadlock avoidance requires that the operating system be given additional information in advance concerning which resources a process will request and use during its lifetime. The system can then decide for each request whether or not the process should wait.

-   **Safe State:** A state is safe if the system can allocate resources to each process (up to its maximum) in some order and still avoid a deadlock.
-   **Resource-Allocation-Graph Algorithm:** For a system with single instances of each resource type, we can use a variant of the resource-allocation graph for deadlock avoidance.
-   **Banker's Algorithm:** For a system with multiple instances of each resource type, the banker's algorithm can be used. It is less efficient than the resource-allocation-graph algorithm.

## Deadlock Detection

If a system does not employ either a deadlock-prevention or a deadlock-avoidance algorithm, then a deadlock situation may occur. In this environment, the system must provide:

-   An algorithm that examines the state of the system to determine whether a deadlock has occurred.
-   An algorithm to recover from the deadlock.

A detection-and-recovery scheme requires overhead that includes not only the run-time costs of maintaining the necessary information and executing the detection algorithm but also the potential losses inherent in recovering from a deadlock.

## Recovery from Deadlock

When a detection algorithm determines that a deadlock exists, the system must recover from the deadlock. There are two options for breaking a deadlock:

1.  **Process Termination:**
    -   Abort all deadlocked processes.
    -   Abort one process at a time until the deadlock cycle is eliminated.
2.  **Resource Preemption:**
    -   **Selecting a victim:** Which resources and which processes are to be preempted?
    -   **Rollback:** If we preempt a resource from a process, what should be done with that process?
    -   **Starvation:** How do we ensure that starvation will not occur?